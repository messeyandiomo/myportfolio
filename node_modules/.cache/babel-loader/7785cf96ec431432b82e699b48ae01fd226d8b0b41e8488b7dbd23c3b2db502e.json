{"ast":null,"code":"// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n\n'use strict';\n\nvar consts = require('./consts'),\n  BufferCursor = require('buffercursor'),\n  BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n  ipaddr = require('ipaddr.js'),\n  assert = require('assert'),\n  util = require('util');\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\nvar Packet = module.exports = function () {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = []; // TODO: DEPRECATED! Use `.edns.options` instead!\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\nvar isPointer = function (len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\nfunction nameUnpack(buff) {\n  var len,\n    comp,\n    end,\n    pos,\n    part,\n    combine = '';\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp) end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n    part = buff.toString('ascii', len);\n    if (combine.length) combine = combine + '.' + part;else combine = part;\n    len = buff.readUInt8();\n    if (!comp) end = buff.tell();\n  }\n  buff.seek(end);\n  return combine;\n}\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\nvar WRITE_HEADER = 100001,\n  WRITE_TRUNCATE = 100002,\n  WRITE_QUESTION = 100003,\n  WRITE_RESOURCE_RECORD = 100004,\n  WRITE_RESOURCE_WRITE = 100005,\n  WRITE_RESOURCE_DONE = 100006,\n  WRITE_RESOURCE_END = 100007,\n  WRITE_EDNS = 100008,\n  WRITE_END = 100009,\n  WRITE_A = consts.NAME_TO_QTYPE.A,\n  WRITE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n  WRITE_NS = consts.NAME_TO_QTYPE.NS,\n  WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  WRITE_PTR = consts.NAME_TO_QTYPE.PTR,\n  WRITE_SPF = consts.NAME_TO_QTYPE.SPF,\n  WRITE_MX = consts.NAME_TO_QTYPE.MX,\n  WRITE_SRV = consts.NAME_TO_QTYPE.SRV,\n  WRITE_TXT = consts.NAME_TO_QTYPE.TXT,\n  WRITE_SOA = consts.NAME_TO_QTYPE.SOA,\n  WRITE_OPT = consts.NAME_TO_QTYPE.OPT,\n  WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  WRITE_TLSA = consts.NAME_TO_QTYPE.TLSA;\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += packet.header.qr << 15 & 0x8000;\n  val += packet.header.opcode << 11 & 0x7800;\n  val += packet.header.aa << 10 & 0x400;\n  val += packet.header.tc << 9 & 0x200;\n  val += packet.header.rd << 8 & 0x100;\n  val += packet.header.ra << 7 & 0x80;\n  val += packet.header.res1 << 6 & 0x40;\n  val += packet.header.res2 << 5 & 0x20;\n  val += packet.header.res3 << 4 & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question');\n  // aren't used\n  buff.writeUInt16BE(1);\n  // answer offset 6\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF);\n  // authority offset 8\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF);\n  // additional offset 10\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= 1 << 9 & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n  switch (section) {\n    case 'answer':\n      pos = 6;\n      // seek to authority and clear it and additional out\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n    case 'authority':\n      pos = 8;\n      // seek to additional and clear it out\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n    case 'additional':\n      pos = 10;\n      break;\n  }\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n  buff.seek(last_resource); // TODO: last_resource not defined!\n  return WRITE_END;\n}\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n  // to the correct value by 'writeResourceDone'\n  return val.type;\n}\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function (b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n  for (var i = 0, len = val.data.length; i < len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n  return WRITE_RESOURCE_DONE;\n}\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6698\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\nfunction writeOpt(buff, val) {\n  var opt;\n  for (var i = 0, len = val.options.length; i < len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n  return WRITE_RESOURCE_DONE;\n}\nPacket.write = function (buff, packet) {\n  var state = WRITE_HEADER,\n    val,\n    section,\n    count,\n    rdata,\n    last_resource,\n    label_index = {};\n  buff = new BufferCursor(buff);\n\n  // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\") state = makeEdns(packet);\n\n  // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n          break;\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n        case WRITE_END:\n          return buff.tell();\n        default:\n          if (typeof val.data !== 'object') throw new Error('Packet.write Unknown State: ' + state);\n          // write unhandled RR type\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = val & 0xF;\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1);\n  // TODO handle qdcount > 1 in practice no one sends this\n  return PARSE_RESOURCE_RECORD;\n}\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\nfunction parseA(val, msg) {\n  var address = '' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':';\n    // TODO zero compression\n    address += msg.readUInt16BE().toString(16);\n  }\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n  return PARSE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = val.ttl >> 16 & 0xFF;\n  val.do = val.ttl >> 15 & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n  packet.edns_options = val.options;\n  packet.payload = val.class;\n  // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n  return PARSE_RESOURCE_DONE;\n}\nvar PARSE_HEADER = 100000,\n  PARSE_QUESTION = 100001,\n  PARSE_RESOURCE_RECORD = 100002,\n  PARSE_RR_UNPACK = 100003,\n  PARSE_RESOURCE_DONE = 100004,\n  PARSE_END = 100005,\n  PARSE_A = consts.NAME_TO_QTYPE.A,\n  PARSE_NS = consts.NAME_TO_QTYPE.NS,\n  PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  PARSE_SOA = consts.NAME_TO_QTYPE.SOA,\n  PARSE_PTR = consts.NAME_TO_QTYPE.PTR,\n  PARSE_MX = consts.NAME_TO_QTYPE.MX,\n  PARSE_TXT = consts.NAME_TO_QTYPE.TXT,\n  PARSE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n  PARSE_SRV = consts.NAME_TO_QTYPE.SRV,\n  PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  PARSE_OPT = consts.NAME_TO_QTYPE.OPT,\n  PARSE_SPF = consts.NAME_TO_QTYPE.SPF,\n  PARSE_TLSA = consts.NAME_TO_QTYPE.TLSA;\nPacket.parse = function (msg) {\n  var state, pos, val, rdata, section, count;\n  var packet = new Packet();\n  pos = 0;\n  state = PARSE_HEADER;\n  msg = new BufferCursor(msg);\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n        break;\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n      case PARSE_END:\n        return packet;\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};","map":{"version":3,"names":["consts","require","BufferCursor","BufferCursorOverflow","ipaddr","assert","util","assertUndefined","val","msg","Packet","module","exports","header","id","qr","opcode","aa","tc","rd","ra","res1","res2","res3","rcode","question","answer","authority","additional","edns_options","payload","undefined","LABEL_POINTER","isPointer","len","nameUnpack","buff","comp","end","pos","part","combine","readUInt8","tell","seek","toString","length","namePack","str","index","offset","dot","writeUInt16BE","indexOf","slice","writeUInt8","write","WRITE_HEADER","WRITE_TRUNCATE","WRITE_QUESTION","WRITE_RESOURCE_RECORD","WRITE_RESOURCE_WRITE","WRITE_RESOURCE_DONE","WRITE_RESOURCE_END","WRITE_EDNS","WRITE_END","WRITE_A","NAME_TO_QTYPE","A","WRITE_AAAA","AAAA","WRITE_NS","NS","WRITE_CNAME","CNAME","WRITE_PTR","PTR","WRITE_SPF","SPF","WRITE_MX","MX","WRITE_SRV","SRV","WRITE_TXT","TXT","WRITE_SOA","SOA","WRITE_OPT","OPT","WRITE_NAPTR","NAPTR","WRITE_TLSA","TLSA","writeHeader","packet","writeTruncate","section","readUInt16BE","count","last_resource","writeQuestion","label_index","name","type","class","writeResource","rdata","ttl","writeUInt32BE","writeResourceDone","writeIp","address","parse","toByteArray","forEach","b","writeCname","data","writeTxt","i","dataLen","Buffer","byteLength","writeMx","priority","exchange","writeSrv","weight","port","target","writeSoa","primary","admin","serial","refresh","retry","expiration","minimum","writeInt32BE","writeNaptr","order","preference","flags","service","regexp","replacement","writeTlsa","usage","selector","matchingtype","copy","makeEdns","edns","options","push","writeOpt","opt","code","state","edns_version","Error","e","parseHeader","Array","PARSE_QUESTION","parseQuestion","PARSE_RESOURCE_RECORD","parseRR","readUInt32BE","parseA","PARSE_RESOURCE_DONE","parseAAAA","compressed","parseCname","parseTxt","parseMx","parseSrv","parseSoa","readInt32BE","parseNaptr","parseTlsa","buffer","parseOpt","buf","version","do","z","eof","PARSE_HEADER","PARSE_RR_UNPACK","PARSE_END","PARSE_A","PARSE_NS","PARSE_CNAME","PARSE_SOA","PARSE_PTR","PARSE_MX","PARSE_TXT","PARSE_AAAA","PARSE_SRV","PARSE_NAPTR","PARSE_OPT","PARSE_SPF","PARSE_TLSA"],"sources":["/home/bilal/ReactLabs/myportfolio/node_modules/native-dns-packet/packet.js"],"sourcesContent":["// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n\n'use strict';\n\nvar consts = require('./consts'),\n    BufferCursor = require('buffercursor'),\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n    ipaddr = require('ipaddr.js'),\n    assert = require('assert'),\n    util = require('util');\n\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\n\nvar Packet = module.exports = function() {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = [];   // TODO: DEPRECATED! Use `.edns.options` instead!\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\n\nvar isPointer = function(len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\n\nfunction nameUnpack(buff) {\n  var len, comp, end, pos, part, combine = '';\n\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp)\n        end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n\n    part = buff.toString('ascii', len);\n\n    if (combine.length)\n      combine = combine + '.' + part;\n    else\n      combine = part;\n\n    len = buff.readUInt8();\n\n    if (!comp)\n      end = buff.tell();\n  }\n\n  buff.seek(end);\n\n  return combine;\n}\n\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\n\nvar\n  WRITE_HEADER              = 100001,\n  WRITE_TRUNCATE            = 100002,\n  WRITE_QUESTION            = 100003,\n  WRITE_RESOURCE_RECORD     = 100004,\n  WRITE_RESOURCE_WRITE      = 100005,\n  WRITE_RESOURCE_DONE       = 100006,\n  WRITE_RESOURCE_END        = 100007,\n  WRITE_EDNS                = 100008,\n  WRITE_END                 = 100009,\n  WRITE_A     = consts.NAME_TO_QTYPE.A,\n  WRITE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\n  WRITE_NS    = consts.NAME_TO_QTYPE.NS,\n  WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  WRITE_PTR   = consts.NAME_TO_QTYPE.PTR,\n  WRITE_SPF   = consts.NAME_TO_QTYPE.SPF,\n  WRITE_MX    = consts.NAME_TO_QTYPE.MX,\n  WRITE_SRV   = consts.NAME_TO_QTYPE.SRV,\n  WRITE_TXT   = consts.NAME_TO_QTYPE.TXT,\n  WRITE_SOA   = consts.NAME_TO_QTYPE.SOA,\n  WRITE_OPT   = consts.NAME_TO_QTYPE.OPT,\n  WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  WRITE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\n\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += (packet.header.qr << 15) & 0x8000;\n  val += (packet.header.opcode << 11) & 0x7800;\n  val += (packet.header.aa << 10) & 0x400;\n  val += (packet.header.tc << 9) & 0x200;\n  val += (packet.header.rd << 8) & 0x100;\n  val += (packet.header.ra << 7) & 0x80;\n  val += (packet.header.res1 << 6) & 0x40;\n  val += (packet.header.res2 << 5) & 0x20;\n  val += (packet.header.res3 << 4) & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question');\n  // aren't used\n  buff.writeUInt16BE(1);\n  // answer offset 6\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF);\n  // authority offset 8\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF);\n  // additional offset 10\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\n\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= (1 << 9) & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n  switch (section) {\n    case 'answer':\n      pos = 6;\n      // seek to authority and clear it and additional out\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n    case 'authority':\n      pos = 8;\n      // seek to additional and clear it out\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n    case 'additional':\n      pos = 10;\n      break;\n  }\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n  buff.seek(last_resource);      // TODO: last_resource not defined!\n  return WRITE_END;\n}\n\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n                         // to the correct value by 'writeResourceDone'\n  return val.type;\n}\n\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function(b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n  for (var i=0,len=val.data.length; i<len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6698\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\n\nfunction writeOpt(buff, val) {\n  var opt;\n  for (var i=0, len=val.options.length; i<len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n  return WRITE_RESOURCE_DONE;\n}\n\nPacket.write = function(buff, packet) {\n  var state = WRITE_HEADER,\n      val,\n      section,\n      count,\n      rdata,\n      last_resource,\n      label_index = {};\n\n  buff = new BufferCursor(buff);\n\n  // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\")\n    state = makeEdns(packet);\n\n  // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n          break;\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n        case WRITE_END:\n          return buff.tell();\n        default:\n          if (typeof val.data !== 'object')\n            throw new Error('Packet.write Unknown State: ' + state);\n          // write unhandled RR type\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = (val & 0xF);\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\n\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1);\n  // TODO handle qdcount > 1 in practice no one sends this\n  return PARSE_RESOURCE_RECORD;\n}\n\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\n\nfunction parseA(val, msg) {\n  var address = '' +\n    msg.readUInt8() +\n    '.' + msg.readUInt8() +\n    '.' + msg.readUInt8() +\n    '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':';\n    // TODO zero compression\n    address += msg.readUInt16BE().toString(16);\n  }\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n  return PARSE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = (val.ttl >> 16) & 0xFF;\n  val.do = (val.ttl >> 15) & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n  packet.edns_options = val.options;\n  packet.payload = val.class;\n  // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n  return PARSE_RESOURCE_DONE;\n}\n\nvar\n  PARSE_HEADER          = 100000,\n  PARSE_QUESTION        = 100001,\n  PARSE_RESOURCE_RECORD = 100002,\n  PARSE_RR_UNPACK       = 100003,\n  PARSE_RESOURCE_DONE   = 100004,\n  PARSE_END             = 100005,\n  PARSE_A     = consts.NAME_TO_QTYPE.A,\n  PARSE_NS    = consts.NAME_TO_QTYPE.NS,\n  PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  PARSE_SOA   = consts.NAME_TO_QTYPE.SOA,\n  PARSE_PTR   = consts.NAME_TO_QTYPE.PTR,\n  PARSE_MX    = consts.NAME_TO_QTYPE.MX,\n  PARSE_TXT   = consts.NAME_TO_QTYPE.TXT,\n  PARSE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\n  PARSE_SRV   = consts.NAME_TO_QTYPE.SRV,\n  PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  PARSE_OPT   = consts.NAME_TO_QTYPE.OPT,\n  PARSE_SPF   = consts.NAME_TO_QTYPE.SPF,\n  PARSE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\n  \n\nPacket.parse = function(msg) {\n  var state,\n      pos,\n      val,\n      rdata,\n      section,\n      count;\n\n  var packet = new Packet();\n\n  pos = 0;\n  state = PARSE_HEADER;\n\n  msg = new BufferCursor(msg);\n\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n        break;\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n      case PARSE_END:\n        return packet;\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}